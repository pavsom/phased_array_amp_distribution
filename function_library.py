import pandas as pd
import numpy as np
import numba as nb
import numexpr as ne
import mpmath as mp
from scipy.optimize import fsolve

# Функция чтения данных координат излучателей из .csv файла и сортировки их построчно

# Входные данные:
# file - наименование файла

# Выходные данные:
# x - номера излучателей в строке в формате [0, M]
# y - номера излучателей в столбце в формате [0, M]
# data_x - отсортированные координаты излучателей по оси Х, м
# data_y - отсортированные координаты излучателей по оси Y, м


def data_read(file):
    # Чтение данных и .csv файла и перевод их из мм в м
    data_import = pd.read_csv(file, delimiter=',') / 1000

    # Сортировка координат излучателей по оси Y
    data_import = data_import.sort_values('Y')

    # Разделение общего массива координат на подмассивы длинной в 1 строку излучаталей по оси Х
    parts = np.split(data_import, len(np.unique(data_import.Y)))

    # Сортировка излучателей в каждой строке по оси Х
    for i in range(len(parts)):
        parts[i] = parts[i].sort_values('X')

    # Обнуление исхондого массива
    data_import = data_import[data_import.X > 10]

    # Объединение отсортированных строк в один массив
    for i in range(len(parts)):
        data_import = pd.concat([data_import, parts[i]])

    # Разделение полученного массива на 2 - координаты по оси Х и по оси Y
    data_x = np.array(data_import['X'])
    data_y = np.array(data_import['Y'])

    # Создание массивов номеров излучателей по строке и столбцу в формате [0, M]
    x = np.int64(np.arange(len(np.unique(data_x)) / 2))
    y = np.arange(len(np.unique(data_y)))

    return [x, y, data_x, data_y]


# Функция вычисления ДН антенной решётки (не работает для одномерной ДН)

# Входные данные:
# u - массив углов для вычисления ДН, напр. косинусы
# v - массив углов для вычисления ДН, напр. косинусы
# amp_phase - амплитудно-фазовое распределение возбуждающих токов по излучателям (слева направо, сверху вниз)
# data_x - отсортированные координаты излучателей по оси Х, м
# data_y - отсортированные координаты излучателей по оси Y, м
# k - волновое число, рад/м
# self_pattern - ДН одного излучателя

# Выходные данные:
# F - ненормированная комплексная двумерная диаграмма направленности

def DN_form(u, v, amp_phase, data_x, data_y, k, self_pattern):
    # Создание пустого массива ДН для заполнения
    F = np.array([[0j] * len(u)] * len(v))

    # Ускоренная функция вычисления множителя антенной решётки
    # Декоратор njit, который переводит питон-код в с-код с использованием многопоточности и параллельности
    @nb.njit(fastmath=True, parallel=True, nogil=True, cache=True)
    def fast_calc(u, v, amp_phase, data_x, data_y, k, F):
        for i in nb.prange(len(amp_phase)):
            F += np.multiply(amp_phase[i], np.exp(1j * k * (data_x[i] * u + data_y[i] * v)))
        return F

    # Расчёт множителя антенной решётки с вызовом функции, переведённой в с-код
    F = fast_calc(u, v, amp_phase, data_x, data_y, k, F)
    # Умножение множителя антенной решётки на ДН одного излучателя
    F = np.multiply(F, self_pattern)

    return F


# Функция вычисления ДН антенной решётки в альтернативном исполнении
# Может быть использована для вычисления одномерной ДН (для вычисления двумерной ДН рекомендуется использование функции
# DN_form)

# Входные данные:
# u - массив углов для вычисления ДН, напр. косинусы
# v - массив углов для вычисления ДН, напр. косинусы
# amp_phase - амплитудно-фазовое распределение возбуждающих токов по излучателям (слева направо, сверху вниз)
# data_x - отсортированные координаты излучателей по оси Х, м
# data_y - отсортированные координаты излучателей по оси Y, м
# k - волновое число, рад/м

# Выходные данные:
# F - ненормированная комплексная диаграмма направленности


def DN_form_evaluate(u, v, amp_phase, data_x, data_y, k):
    # Создание нулевой ДН
    F = 0

    # Создание словаря для вычисления
    evaluate_dict = {
        'x': None,
        'y': None,
        'A_Ph': amp_phase,
        'k': k,
        'u': u,
        'v': v
    }

    # Вычисление множителя антенной решётки с помощью словаря и библиотеки numexpr
    for i in range(len(data_x)):
        evaluate_dict['x'] = data_x[i]
        evaluate_dict['y'] = data_y[i]
        evaluate_dict['A_Ph'] = amp_phase[i]
        F += ne.evaluate('A_Ph * exp(1j*k*(x*u + y*v))', evaluate_dict)

    # Вычисление ДН одного излучателя
    self_pattern = np.sqrt(np.sqrt(1 - np.power(u, 2) - np.power(v, 2)))
    # Умножение множителя антенной решётки на ДН одного излучателя
    F = np.multiply(F, self_pattern)

    return F


# Функция вычисления КНД

# Входные данные:
# F - ненормированная комплексная ДН
# el - массив углов по углу места, рад.
# az - массив углов по азимуту, рад.

# Выходные данные:
# directivity - КНД, дБ

def directivity_calc(F, el, az):
    # Нормирование полной ДН
    F = abs(F) / abs(F.max())
    # Переход в сферические координаты
    theta = np.radians(90) - el
    # Удаление значение NaN из массива ДН
    F[np.isnan(F)] = 0
    # Вычисление всей энергии ДН
    total_power = np.trapz(np.trapz(np.power(F, 2) * np.sin(theta), x=el), x=az)
    # Вычисление КНД
    directivity = 10 * np.log10(4 * np.pi / total_power)

    return directivity


# Функция вычисления ширина главного лепестка ДН по уровню -3дБ

# Входные данные:
# F - нормированная ДН, дБ
# *angles - массивы углов (функция может применяться для расчёта ширины главного лепестка как в одной плоскости, так и
# в двух, для расчёта в одной плоскости на вход функции передаётся один массив углов (рад.), для расчёта в двух
# плоскостях - два)

# Выходные данные:
# width_el - ширина ГЛ по углу места, градусы
# width_az - ширина ГЛ по азимуту, градусы
# width - ширина ГЛ в случае расчёта по одной плоскости, градусы


def find_delta_3dB(F, *angles):
    # Проверка количества входных аргументов
    # Если массивов углов 2 - вычисление ширины ГЛ в двух плоскостях
    if len(angles) == 2:
        az = angles[0]
        el = angles[1]
        [i_start, j_start] = np.where(F == F.max())
        i = i_start
        j = j_start

        while F[i, j] > -3:
            i = i + 1
        bottom = i - 1

        i = i_start

        while F[i, j] > -3:
            i = i - 1
        top = i + 1

        i = i_start

        while F[i, j] > -3:
            j = j + 1
        right = j - 1

        j = j_start

        while F[i, j] > -3:
            j = j - 1
        left = j + 1

        width_el = np.degrees(el[bottom] - el[top])
        width_az = np.degrees(az[right] - az[left])
        return width_az[0], width_el[0]
    # Если массив углов один - вычисление ширины ГЛ в одной плоскости
    elif len(angles) == 1:
        angle = angles[0]
        i_start = np.where(F == F.max())[0]
        i = i_start

        while F[i] > -3:
            i = i + 1
        right = i - 1

        i = i_start

        while F[i] > -3:
            i = i - 1
        left = i + 1

        width = np.degrees(angle[right] - angle[left])
        return width[0]


# Функция вычисления отсчётов Котельникова по ДН

# Входные данные:
# ax - ось излучателей, по которой происходит вычисление (строка или столбец)
# angles - массив углов, по которому происходит вычисление, напр. косинусы
# F_mask - одномерная ненормированная ДН с маской

# Выходные данные:
# N - отсчёты Котельникова


def kotelnik(ax, angles, F_mask):
    # Создание пустого массива отсчётов
    N = np.array([0j] * len(ax))
    # Вычисление шага интегрирования
    step = abs(angles[1] - angles[0])

    # Вычисление отсчётов Котельникова с помощью численного интегрирования
    for i in range(len(ax)):
        for j in range(len(angles) - 1):
            N[i] = N[i] + step * (F_mask[j] * np.sinc((len(ax) * angles[j] - np.pi * ax[i]) / np.pi) +
                                  F_mask[j + 1] * np.sinc((len(ax) * angles[j + 1] - np.pi * ax[i]) / np.pi)) / 2

    # Нормирование отсчётов Котельникова
    N = N * (len(ax) / np.pi)

    return N


# Функция расчёта ДН с помощью отсчётов Котельникова (для контроля)

# Входные данные:
# ax - ось излучателей, по которой происходит вычисление (строка или столбец)
# angles - массив углов, по которому происходит вычисление, напр. косинусы
# N - отсчёты Котельникова

# Выходные данные:
# F - ненормированная одномерная ДН


# Декоратор njit, который переводит питон-код в с-код с использованием многопоточности и параллельности
@nb.njit(fastmath=True, parallel=True, nogil=True, cache=True)
def DN_form_kotelnik(ax, angles, N):
    # Создание пустого массива ДН
    F = np.array([0j] * len(angles))

    # Расчёт ДН
    for i in nb.prange(len(ax)):
        F += N[i] * np.sinc((len(ax) * angles - np.pi * ax[i]) / np.pi)

    return F


# Функция вычисления комплексных токов излучателей по отсчётам Котельникова

# Входные данные:
# ax - ось излучателей, по которой происходит вычисление (строка или столбец)
# N - отсчёты Котельникова

# Выходные данные:
# I - массив комплексных токов


# Декоратор njit, который переводит питон-код в с-код с использованием многопоточности и параллельности
@nb.njit(fastmath=True, parallel=True, nogil=True, cache=True)
def current_form(ax, N):
    # Создание пустого массива комплексных токов
    I = np.array([0j] * len(ax))

    # Вычисление комплексных токов
    for i in nb.prange(len(ax)):
        for j in nb.prange(len(ax)):
            I[i] = I[i] + N[j] * np.exp(1j * np.pi * ax[j] * (1 - 1/len(ax) - 2 * i / len(ax)))

    return I


# Функция вычисления полинома Чебышева n-го порядка

# Входные данные:
# n - порядок полинома Чебышева
# x0 - координата для вычисления полинома

# Выходные данные:
# T - значение полинома Чебышева n-го порядка в точке x0

# Примечание: вычисление полинома Чебышева n-го порядка происходит через тригонометрическое представление


def chebyshev(n, x0):
    if x0 < -1:
        T = (-1)**n * np.cosh(n * np.arccosh(abs(x0)))
    elif abs(x0) <= 1:
        T = np.cos(n * np.arccos(x0))
    else:
        T = np.cosh(n * np.arccosh(x0))

    return T


# Функция генерации амплитудного распределения Дольфа-Чебышева

# Входные данные:
# SLR_X - требуемый уровень боковых лепестков по азимуту по отношению к главному лепестку, разы (должен быть > 1)
# SLR_Y - требуемый уровень боковых лепестков по углу места по отношению к главному лепестку, разы (должен быть > 1)
# N1 - количество излучателей в решётке по оси Х
# N2 - количество излучателей в решётке по оси Y

# Выходные данные
# A_xy - двухмерное нормированное амплитудное распределение
# amp_x - нормированное амплитудное распределение, соотетствующее одной сроке излучателей
# amp_y - нормированное амлитудное распределение, соотвествующее одному столбцу излучателей

# Примечание: для оптимизации полученного распределения по КИП требуется отслеживание амплитудных распределений
# по строке и столбцу. Оптимальным называется случай, при котором уровень амплитуды на краю раскрыва антенны
# соответствует уровню амплитуды в центре раскрыва. Для этого в выходные данные добавлены массивы amp_x и amp_y.
# По ним можно построить графики для отслеживания амплитудного распределения в строке и столбце.


def dolf_chebyshev_distribution(SLR_X_dB, SLR_Y_dB, N1, N2):
    # Пересчёт УБЛ из дБ в разы
    SLR_X = 10 ** (SLR_X_dB / 20)
    SLR_Y = 10 ** (SLR_Y_dB / 20)

    # Вычисление параметра х0 для генерации амплитудного распределния Дольф-Чебышева по строке
    x01 = np.cosh(np.arccosh(SLR_X) / (N1 - 1))
    # Создание пустого массива амплитудного распределения по строке
    A1 = np.array([0.0j] * N1)
    # Вычисление амплитудного распределения по строке по заданным параметрам с помощью полиномов Чебышева
    for n in range(N1):
        for m in range(1, N1 + 1):
            A1[n] = A1[n] + chebyshev(N1 - 1, x01 * np.cos(np.pi * m / N1)) * np.exp(-1j * (2 * (n + 1) - N1 - 1)
                                                                                     * np.pi * m / N1)
        A1[n] = A1[n] / N1

    # Нормирование амплитудного распределения по строке
    amp_x = abs(A1) / abs(A1).max()

    # Вычисление параметра х0 для генерации амплитудного распределния Дольф-Чебышева по столбцу
    x02 = np.cosh(np.arccosh(SLR_Y) / (N2 - 1))
    # Создание пустого массива амплитудного распределения по столбцу
    A2 = np.array([0.0j] * N2)
    # Вычисление амплитудного распределения по столбцу по заданным параметрам с помощью полиномов Чебышева
    for n in range(N2):
        for m in range(1, N2 + 1):
            A2[n] = A2[n] + chebyshev(N2 - 1, x02 * np.cos(np.pi * m / N2)) * np.exp(-1j * (2 * (n + 1) - N2 - 1)
                                                                                     * np.pi * m / N2)
        A2[n] = A2[n] / N2

    # Нормирование амплитудного распределения по столбцу
    amp_y = abs(A2) / abs(A2).max()

    # Создание пустого массива двухмерного амплитудного распределения
    A_xy = np.array([[0.0] * N1] * (2 * N2))
    # Вычисление каждого элемента двухмерного массива как произведения соответствующих элементов строки и столбца
    # ВАЖНО!!! В силу гексогональности решётки строки в каждом столбце сдвинуты друг относительно друга. Из-за этого
    # приходится искуственно вдвое уменьшать количество элементов в столбце. Учёт этого уменьшения происходит в
    # amp_y[i // 2]
    for i in range(2 * N2):
        for j in range(N1):
            A_xy[i, j] = amp_x[j] * amp_y[i // 2]

    # Нормирование двухмерного амплитудного распределения
    A_xy = A_xy / A_xy.max()

    return amp_x, amp_y, A_xy


# Функция для решения нелинейного уравнения вида 20lg(sinh(pi*x)/(pi*x)) + 13.2614 = SLR
# С помощью решения этого уравнения вычисляется параметр В, отвечающий за смещение первого бокового лепестка
# диаграммы направленности

# Входные данные:
# x - переменная уравнения, на вход подаётся её начальное приближение
# SLR_dB - желаемый уровень первого бокового лепестка, дБ

# Выходные данные:
# На выходе функция возвращает значение, вычисленное с помощью поданного на вход значения переменной.
# Далее метод fsolve проводит необходиоме количество итераций, чтобьы приблизить это значение к 0.


def f(x, SLR_dB):
    return 20 * np.log10(np.sinh(np.pi * x) / (np.pi * x)) + 13.2614 - SLR_dB


# Функция генерации однопараметрического распределения Тейлора

# Входные данные:
# SLR_X - требуемый уровень боковых лепестков по азимуту по отношению к главному лепестку, разы (должен быть > 1)
# SLR_Y - требуемый уровень боковых лепестков по углу места по отношению к главному лепестку, разы (должен быть > 1)
# N1 - количество излучателей в решётке по оси Х
# N2 - количество излучателей в решётке по оси Y

# Выходные данные
# A_xy - двухмерное нормированное амплитудное распределение
# amp_x - нормированное амплитудное распределение, соотетствующее одной сроке излучателей
# amp_y - нормированное амлитудное распределение, соотвествующее одному столбцу излучателей

# Примечание: для удобства анализа в выходные данные также добавлены амлитудные распределения в одной строке
# и одном столбце излучателей антенной решётки.


def taylor_1_param(SLR_X_dB, SLR_Y_dB, N1, N2):

    # Задание параметров для последующего вычисления модифицированной функции Бесселя
    mp.dps = 15
    mp.pretty = True

    # Решение уравнения f(x, SLR_X_dB) = 0
    B_x = fsolve(f, 1, SLR_X_dB)
    # Создание оси Х для вычисления вдоль неё амплитудного распределения
    p_x = np.linspace(-1, 1, num=N1, endpoint=True)

    # Создание пустого массива амплитудного распределения по строке
    amp_x = np.array([0.0] * N1)
    # Вычисление амплитудного распределения в строке излучателей
    for i in range(N1):
        amp_x[i] = mp.besseli(0, np.pi * B_x[0] * np.sqrt(1 - p_x[i]**2))

    # Нормирование полученного амплитудного распределения
    amp_x = amp_x / amp_x.max()

    # Решение уравнения f(x, SLR_Y_dB) = 0
    B_y = fsolve(f, 1, SLR_Y_dB)
    # Создание оси Y для вычисления вдоль неё амплитудного распределения
    p_y = np.linspace(-1, 1, num=N2, endpoint=True)

    # Создание пустого массива амплитудного распределения по столбцу
    amp_y = np.array([0.0] * N2)
    # Вычисление амплитудного распределения в столбце излучателей
    for i in range(N2):
        amp_y[i] = mp.besseli(0, np.pi * B_y[0] * np.sqrt(1 - p_y[i]**2))

    # Нормирование полученного амплитудного распределения
    amp_y = amp_y / amp_y.max()

    # Создание пустого массива двухмерного амплитудного распределения
    A_xy = np.array([[0.0] * N1] * (2 * N2))
    # Вычисление каждого элемента двухмерного массива как произведения соответствующих элементов строки и столбца
    # ВАЖНО!!! В силу гексогональности решётки строки в каждом столбце сдвинуты друг относительно друга. Из-за этого
    # приходится искуственно вдвое уменьшать количество элементов в столбце. Учёт этого уменьшения происходит в
    # amp_y[i // 2]
    for i in range(2 * N2):
        for j in range(N1):
            A_xy[i, j] = amp_x[j] * amp_y[i // 2]

    # Нормирование двухмерного амплитудного распределения
    A_xy = A_xy / A_xy.max()

    return amp_x, amp_y, A_xy


# Функция генерации n-параметрического распределения Тейлора

# Входные данные:
# SLR_X - требуемый уровень боковых лепестков по азимуту по отношению к главному лепестку, разы (должен быть > 1)
# SLR_Y - требуемый уровень боковых лепестков по углу места по отношению к главному лепестку, разы (должен быть > 1)
# N1 - количество излучателей в решётке по оси Х
# N2 - количество излучателей в решётке по оси Y
# n - параметр амплитудного распределения

# Выходные данные
# A_xy - двухмерное нормированное амплитудное распределение
# amp_x - нормированное амплитудное распределение, соотетствующее одной сроке излучателей
# amp_y - нормированное амлитудное распределение, соотвествующее одному столбцу излучателей

# Примечание: для удобства анализа в выходные данные также добавлены амлитудные распределения в одной строке
# и одном столбце излучателей антенной решётки.


def taylor_n_param(SLR_X_dB, SLR_Y_dB, N1, N2, n):

    # Пересчёт УБЛ из дБ в разы
    SLR_X = 10 ** (SLR_X_dB / 20)
    SLR_Y = 10 ** (SLR_Y_dB / 20)

    # Вычисление параметра А для распределения вдоль строки излучателей
    A_x = (1 / np.pi) * np.log(SLR_X + np.sqrt(SLR_X**2 - 1))
    # Вычисление коэффициента расширения главного лепестка
    sigma_x = n / np.sqrt(A_x**2 + (n - 1/2)**2)

    # Создание пустого массива нулей ДН по строке
    z_x = np.array([0.0] * n)
    # Вычсиление координат первых n нулей ДН по строке
    for i in range(n):
        z_x[i] = sigma_x * np.sqrt(A_x**2 + (i + 1 - 1/2)**2)

    # Создание пустого массива множителя распределения вдоль строки
    F_x = np.array([1.0] * n)
    # Вычисление массива множителей распределения вдоль строки
    for i in range(n):
        for j in range(n-1):
            F_x[i] = F_x[i] * (1 - i**2 / z_x[j]**2)
        F_x[i] = F_x[i] * (np.math.factorial(n - 1)**2) / (np.math.factorial(n - 1 + i) * np.math.factorial(n - 1 - i))

    # Создание оси Х для вычисления вдольнеё амплитудного распределения
    p_x = np.linspace(-1, 1, num=N1, endpoint=True)

    # Создание пустого массива амплитудного распределения по строке
    amp_x = np.array([0.0] * N1)
    # Вычисление амплитудного распределения в строке излучателей
    for i in range(len(amp_x)):
        for j in range(1, n):
            amp_x[i] = amp_x[i] + F_x[j] * np.cos(j * np.pi * p_x[i])
        amp_x[i] = amp_x[i] * 2 + 1

    # Нормирование полученного амплитудного распределения
    amp_x = amp_x / amp_x.max()

    # Вычисление параметра А для распределения вдоль столбца излучателей
    A_y = (1 / np.pi) * np.log(SLR_Y + np.sqrt(SLR_Y**2 - 1))
    # Вычисление коэффициента расширения главного лепестка
    sigma_y = n / np.sqrt(A_y**2 + (n - 1/2)**2)

    # Создание пустого массива нулей ДН по столбцу
    z_y = np.array([0.0] * n)
    # Вычсиление координат первых n нулей ДН по столбцу
    for i in range(n):
        z_y[i] = sigma_y * np.sqrt(A_y**2 + (i + 1 - 1/2)**2)

    # Создание пустого массива множителя распределения вдоль столбца
    F_y = np.array([1.0] * n)
    # Вычисление массива множителей распределения вдоль столбца
    for i in range(n):
        for j in range(n-1):
            F_y[i] = F_y[i] * (1 - i**2 / z_y[j]**2)
        F_y[i] = F_y[i] * (np.math.factorial(n - 1)**2) / (np.math.factorial(n - 1 + i) * np.math.factorial(n - 1 - i))

    # Создание оси Y для вычисления вдольнеё амплитудного распределения
    p_y = np.linspace(-1, 1, num=N2, endpoint=True)

    # Создание пустого массива амплитудного распределения по столбцу
    amp_y = np.array([0.0] * N2)
    # Вычисление амплитудного распределения в строке излучателей
    for i in range(len(amp_y)):
        for j in range(1, n):
            amp_y[i] = amp_y[i] + F_y[j] * np.cos(j * np.pi * p_y[i])
        amp_y[i] = amp_y[i] * 2 + 1

    # Нормирование полученного амплитудного распределения
    amp_y = amp_y / amp_y.max()

    # Создание пустого массива двухмерного амплитудного распределения
    A_xy = np.array([[0.0] * N1] * (2 * N2))
    # Вычисление каждого элемента двухмерного массива как произведения соответствующих элементов строки и столбца
    # ВАЖНО!!! В силу гексогональности решётки строки в каждом столбце сдвинуты друг относительно друга. Из-за этого
    # приходится искуственно вдвое уменьшать количество элементов в столбце. Учёт этого уменьшения происходит в
    # amp_y[i // 2]
    for i in range(2 * N2):
        for j in range(N1):
            A_xy[i, j] = amp_x[j] * amp_y[i // 2]

    # Нормирование двухмерного амплитудного распределения
    A_xy = A_xy / A_xy.max()

    return amp_x, amp_y, A_xy
